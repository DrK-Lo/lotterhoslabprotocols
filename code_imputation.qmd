# Imputing SNP datasets 
#### Written by M.G.E 2/5/2025
https://github.com/DrK-Lo/lotterhoslabprotocols/blob/main/code_imputation.qmd

## Recommended pre-reading
Before starting the SNP imputation and filtering process, I recommend reading the following:

1. [LEA 3: Factor models in population genetics and ecological genomics with R](https://onlinelibrary.wiley.com/doi/full/10.1111/1755-0998.13366), Gain et al 2021 

2. [These arenâ€™t the loci you're looking for: Principles of effective SNP filtering for molecular ecologists](https://onlinelibrary.wiley.com/doi/full/10.1111/mec.14792), O'Leary et al 2018

3. [Fast and Efficient Estimation of Individual Ancestry Coefficients](https://pmc.ncbi.nlm.nih.gov/articles/PMC3982712/), Frichot et al 2014

If you're short on time, readings 1 and 2 are the most important. The third reading dives further into the ancestry calculations in snmf that we will use for imputation. 

## Background on LEA and impute()
We will be using the impute() function in the LEA package to impute our missing genotypes. impute() requires an .lfmm file as input, and will return a new .lfmm file with an `_imputed.lfmm` suffix. The function takes the follwing arguments: `impute (object, input.file, method, K, run)`. See more details [here](https://rdrr.io/bioc/LEA/man/impute.html). 

## Full vs thinned SNP sets
It is important to understand what type of SNPs you want to retain in your dataset for downstream anaylses. 

## General imputation workflow
1. Transfer your data into a genotype matrix format. We have developed code for extracting genotype values from a VCF using the `extract.gt()` function (see [Preparing SNP matrix](https://drk-lo.github.io/lotterhoslabprotocols/code_imputation.html#preparing-your-snp-matrix) section below).  
2. Filter for missing data. This typically includes: removing low-quality calls (often done by the sequencing facility, but double-check), removing individuals with >10% missing data across all loci, and removing SNPs with >10% missing data across all individuals. 
3. Filter for minor allele frequency (MAF)
4. Impute 
  i. THIS STEP PRODUCES YOUR FULL SNP DATASET  
5. Filter for linkage disequilibrium 
  i. THIS STEP PRODUCES YORU THINNED SNP DATASET


## Preparing your SNP matrix
To prepare to use the `impute()` function, you should arrage your SNP data in a matrix with individuals in rows and your SNPs in columns. If you're starting with a VCF file of genotypes from the sequencing facility, use the `extract.gt()` function to extract the genotype values into a data frame from the VCF. For an example on how to do this, ask for access to the `genotypes_experimental.R` script that was used for the Cvi MVP H2F project. 

## Imputing and producing the full SNP set
Here we have our filtered SNP matrix called `GEN_filtered`. This matrix has been filtered for MAF and missingness.

```
# Impute #####################################################################
# use snmf on our genotype matrix with 154k SNPs
write.lfmm(GEN_filtered, "merged_data/genotypes/20250203_genotypes_exp.lfmm")

exp.project.snmf <- snmf("merged_data/genotypes/20250203_genotypes_exp.lfmm", K = 2, repetitions = 10, ploidy = 2, entropy = TRUE, project = "new")

# run with the lowest cross-entropy value and impute
best = which.min(cross.entropy(exp.project.snmf, K = 2))
impute(exp.project.snmf, "merged_data/genotypes/20250203_genotypes_exp.lfmm", method = 'mode', K = 2, run = best)

# store the imputed SNP set as a matrix 
GEN_imputed <- as.data.frame(read.table("merged_data/genotypes/20250203_genotypes_exp.lfmm_imputed.lfmm", header = FALSE))
saveRDS(GEN_imputed, file = "merged_data/genotypes/20250203_FULLSNPs_exp.rds") # this is the FULL SNP set
```

## Filtering for linkage disequilibrium and producing the thinned SNP set 
Here, we read in the thinned SNP set and use the `bigsnpr` and `bigstatsr` packages to calculate a PCA while filtering for LD. The LD correlation argument is set of a default of `thr.r2 = 0.2`, but this can be explored for your data.  

```
GEN_imputed <- readRDS("/Users/madelineeppley/Desktop/20250203_FULLSNPs_exp.rds")
gen_impute <- add_code256(big_copy(GEN_imputed,type="raw"),code=bigsnpr:::CODE_012)

# double check our dimensions
muts_maf_filtered <- readRDS("/Users/madelineeppley/Desktop/20250203_FULLmuts_exp.rds")
dim(GEN_imputed)
dim(muts_maf_filtered) # matches

thr.r2 <- 0.2
# create the thinned SNP set 
pca_inv <- snp_autoSVD(gen_impute,
                       infos.chr= muts_maf_filtered$Chromosome,
                       infos.pos = muts_maf_filtered$Position,
                       thr.r2=thr.r2,  # correlation LD
                       size= 100/thr.r2, # explore
)

thinned_snps <- attr(pca_inv, which="subset") # SNPs n=104958, this step outputs the integer positions of your SNPs that should be retained in the thinned set
gen_filtered_subset <- GEN_imputed[, thinned_snps] # subset the full imputed dataset by the thinned SNP positions
saveRDS(gen_filtered_subset, file = "/Users/madelineeppley/Desktop/20250203_THINNEDSNPs_exp.rds")
```
